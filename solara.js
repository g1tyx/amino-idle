const icons = {
  tab1: `<svg height="32px" width="32px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" xml:space="preserve" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <circle style="fill:#F4E3C3;" cx="256" cy="256" r="256"></circle>  <g> <circle style="fill:#F1543F;" cx="170.667" cy="298.667" r="42.667"></circle> <circle style="fill:#F1543F;" cx="256" cy="298.667" r="42.667"></circle> </g> <g> <path style="fill:#C1321F;" d="M255.998,256c-0.193,0-0.381,0.012-0.574,0.016v85.304c0.191,0.002,0.381,0.014,0.574,0.014 c23.564,0,42.667-19.103,42.667-42.667S279.562,256,255.998,256z"></path> <circle style="fill:#C1321F;" cx="341.333" cy="298.667" r="42.667"></circle> </g> <circle style="fill:#FC6F58;" cx="213.333" cy="226.263" r="42.667"></circle> <circle style="fill:#F1543F;" cx="298.667" cy="226.263" r="42.667"></circle> <path style="fill:#9A4F03;" d="M385.291,362.02H126.705c-22.85,0-41.374-18.523-41.374-41.374l0,0h341.333l0,0 C426.665,343.497,408.142,362.02,385.291,362.02z"></path> <path style="fill:#804000;" d="M255.426,320.646v41.374h129.867c22.85,0,41.374-18.523,41.374-41.374H255.426z"></path> <circle style="fill:#F1543F;" cx="256.431" cy="154.29" r="42.667"></circle> <path style="fill:#C1321F;" d="M256.429,111.623c-0.336,0-0.669,0.017-1.005,0.026v85.283c0.334,0.007,0.667,0.026,1.005,0.026 c23.564,0,42.667-19.103,42.667-42.667C299.096,130.725,279.993,111.623,256.429,111.623z"></path> </g></svg>`,
  tab2: `<svg height="32px" width="32px" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" xml:space="preserve" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <circle style="fill:#B5F1F4;" cx="256" cy="256" r="256"></circle>    <path style="fill:#FF80AA;" d="M256,342.693l-40.539-40.539c-34.257-34.257-34.257-89.8,0-124.057L256,137.559l40.539,40.539 c34.257,34.257,34.257,89.8,0,124.057L256,342.693z"></path> <path style="fill:#FF6472;" d="M256,137.559l40.539,40.539c34.257,34.257,34.257,89.8,0,124.057L256,342.693V137.559z"></path> <path style="fill:#E2407E;" d="M334.407,146.565l-50.638,26.879c-42.793,22.714-59.068,75.819-36.354,118.612l26.881,50.638 l50.638-26.879c42.793-22.714,59.068-75.819,36.354-118.612L334.407,146.565z"></path> <path style="fill:#FD5790;" d="M232.372,342.693l-50.638-26.879c-42.793-22.714-59.068-75.819-36.354-118.612l26.881-50.638 l50.638,26.879c42.792,22.714,59.068,75.819,36.354,118.612L232.372,342.693z"></path> <path style="fill:#BC2864;" d="M401.051,197.642h-57.33c-48.447,0-87.721,39.274-87.721,87.721v57.33h57.33 c48.447,0,87.721-39.274,87.721-87.721V197.642z"></path> <path style="fill:#A01F5A;" d="M446.492,265.812L446.492,265.812C372.872,234.225,287.585,268.3,256,341.921l0,0l0,0 C329.619,373.508,414.906,339.434,446.492,265.812L446.492,265.812z"></path> <path style="fill:#E2407E;" d="M256,342.693h-57.33c-48.447,0-87.721-39.274-87.721-87.721v-57.33h57.33 c48.447,0,87.721,39.274,87.721,87.721V342.693z"></path> <path style="fill:#BC2864;" d="M256,341.921L256,341.921c-73.619,31.587-158.906-2.488-190.492-76.109l0,0l0,0 C139.128,234.225,224.415,268.302,256,341.921L256,341.921z"></path> </g></svg>`,
  tab3: `<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 512 512" xml:space="preserve" width="32px" height="32px" fill="#000000"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <circle style="fill:#E6F3FF;" cx="256" cy="256" r="256"></circle>  <rect x="162.909" y="256" style="fill:#FD8469;" width="186.182" height="56.889"></rect> <g> <rect x="255.431" y="256" style="fill:#FC6F58;" width="93.66" height="56.889"></rect> <rect x="142.222" y="299.96" style="fill:#FC6F58;" width="227.556" height="56.889"></rect> </g> <g> <rect x="255.431" y="299.96" style="fill:#F1543F;" width="114.347" height="56.889"></rect> <rect x="113.778" y="341.333" style="fill:#F1543F;" width="284.444" height="56.889"></rect> </g> <rect x="255.431" y="341.333" style="fill:#C1321F;" width="142.791" height="56.889"></rect> <g> <rect x="142.222" y="355.556" style="fill:#FD8469;" width="28.444" height="28.444"></rect> <rect x="208.593" y="355.556" style="fill:#FD8469;" width="28.444" height="28.444"></rect> <rect x="274.963" y="355.556" style="fill:#FD8469;" width="28.444" height="28.444"></rect> <rect x="341.333" y="355.556" style="fill:#FD8469;" width="28.444" height="28.444"></rect> </g> <path style="fill:#F9B54C;" d="M180.891,175.766C179.867,220.574,211.365,256,256.184,256s74.924-35.414,74.924-80.234 c0.974-27.874-30.505-73.106-30.505-73.106s-4.91,7.109-11.152,17.132c-14.433-27.314-33.27-54.587-33.27-54.587 s-18.837,27.274-33.27,54.587c-6.242-10.023-11.152-17.132-11.152-17.132S181.52,148.277,180.891,175.766z"></path> <path style="fill:#F4A200;" d="M300.606,102.66c0,0-4.91,7.109-11.152,17.132c-14.433-27.314-33.27-54.587-33.27-54.587 s-0.145,0.21-0.398,0.583v190.204c0.134,0,0.265,0.01,0.398,0.01c44.82,0,74.924-35.414,74.924-80.234 C332.085,147.892,300.606,102.66,300.606,102.66z"></path> <path style="fill:#FFD15D;" d="M200.764,196.996C200.011,229.948,223.175,256,256.136,256s55.099-26.045,55.099-59.004 c0.717-20.499-22.433-53.762-22.433-53.762s-3.61,5.229-8.201,12.598c-10.614-20.087-24.467-40.143-24.467-40.143 s-13.853,20.058-24.467,40.143c-4.591-7.371-8.201-12.598-8.201-12.598S201.226,176.78,200.764,196.996z"></path> <path style="fill:#F9B54C;" d="M288.804,143.232c0,0-3.61,5.229-8.201,12.598c-10.614-20.087-24.467-40.143-24.467-40.143 s-0.122,0.176-0.35,0.51v139.793c0.117,0,0.233,0.009,0.35,0.009c32.961,0,55.099-26.045,55.099-59.004 C311.953,176.497,288.804,143.232,288.804,143.232z"></path> </g></svg>`
};


var visionRuneIcon = `<svg width="30px" height="30px" viewBox="-2.4 -2.4 28.80 28.80" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="#000000" transform="rotate(0)"><g id="SVGRepo_iconCarrier"> <path fill-rule="evenodd" clip-rule="evenodd" d="M2.97924 10.2709C4.36454 8.19808 7.26851 5 12 5C16.7314 5 19.6354 8.19808 21.0207 10.2709C21.4855 10.9665 21.718 11.3143 21.6968 11.9569C21.6757 12.5995 21.4088 12.9469 20.8752 13.6417C19.2861 15.7107 16.1129 19 12 19C7.88699 19 4.71384 15.7107 3.12471 13.6417C2.59106 12.9469 2.32424 12.5995 2.30308 11.9569C2.28193 11.3143 2.51436 10.9665 2.97924 10.2709ZM11.9999 16C14.2091 16 15.9999 14.2091 15.9999 12C15.9999 9.79086 14.2091 8 11.9999 8C9.79081 8 7.99995 9.79086 7.99995 12C7.99995 14.2091 9.79081 16 11.9999 16Z" fill="#162da2"></path> </g></svg>`


const tooltipTexts = {
  "SolaraTab3-Auto-Sacrifice_System_I": "Unlocks auto-sacrifice runes for Cells, Nourishment, Warmth & Energy",
  "SolaraTab3-Auto-Sacrifice_System_II": "Unlocks auto-sacrifice runes for Biomites, Zymers, Fibers, Sludge & Algae",
  "SolaraTab3-33%_Faster_Terraform_Cycle": "Improves all TerraForm resource gains by 33%",
  "SolaraTab3-Autonomous_Mitogenesis": "Your cells learn to divide by themselves",
  "SolaraTab3-Protozoid_Evolutions": "Unlock the next layer of evolution",
  "SolaraTab3-+1_Prestige_Point": "You draw forth knowledge from the depths of a world draped in silent yearning. You realize you can hold on to this, somehow.",
  "SolaraTab3-Endosymbiosis": "You and Solara reach towards each other. Within her hushed whispers, you find a kindred spirit, a desire to merge into an existence where two become one, echoing loudly through the caverns of love and desolation."
};


let sacrificePoolCanvas;
let sacrificePoolCtx;
let sacrificePoolCanvasWidth;
let sacrificePoolCanvasHeight;
let lastOccupiedPixelInRow;


const sacrificeHandlers = {
  cellSacrificeCosts: () => cellSacrifice(),
  nourishmentSacrificeCosts: () => nourishmentSacrifice(),
  warmthSacrificeCosts: () => warmthSacrifice(),
  energySacrificeCosts: () => energySacrifice(),
  biomitesSacrificeCosts: () => biomiteSacrifice(),
  zymersSacrificeCosts: () => zymerSacrifice(),
  fibersSacrificeCosts: () => fiberSacrifice(),
  sludgeSacrificeCosts: () => sludgeSacrifice()
};

const resourceVariableNames = {
  'cell': 'cellworkers',
  'nourishment': 'nourishment',
  'warmth': 'warmth',
  'energy': 'energy',
  'biomites': 'biomites',
  'zymers': 'zymers',
  'fibers': 'fibers',
  'sludge': 'sludge'
};

const sacrificeFunctions = {
  'cell': cellSacrifice,
  'nourishment': nourishmentSacrifice,
  'warmth': warmthSacrifice,
  'energy': energySacrifice,
  'biomites': biomiteSacrifice,
  'zymers': zymerSacrifice,
  'fibers': fiberSacrifice,
  'sludge': sludgeSacrifice
};


function canSacrifice(resource, cost) {
    if (resource >= cost) {
        return true;
    }
    return false;
}


function deductResources(resourceType, cost) {
    switch(resourceType) {
        case 'cellworkers':
            cellworkers -= cost;
            totalcellworkers -= cost;
            break;
        case 'nourishment':
            nourishment -= cost;
            break;
        case 'warmth':
            warmth -= cost;
            break;
        case 'energy':
            energy -= cost;
            break;
        case 'biomites':
            biomites -= cost;
            document.getElementById("biomitesCounter").textContent = formatLargeNumber(biomites);
            break;
        case 'zymers':
            zymers -= cost;
            document.getElementById("zymersCounter").textContent = formatLargeNumber(zymers);
            break;
        case 'fibers':
            fibers -= cost;
            document.getElementById("fibersCounter").textContent = formatLargeNumber(fibers);
            break;
        case 'sludge':
            sludge -= cost;
            document.getElementById("sludgeCounter").textContent = formatLargeNumber(sludge);
            break;
        default:
            console.error(`Unknown resource type: ${resourceType}`);
            break;
    }
}




function flashButtonRed(buttonId) {
    let button = document.getElementById(buttonId);
    if (button) {
        button.style.backgroundColor = 'red';
        setTimeout(() => {
            button.style.backgroundColor = '';  // Resetting the button color back to its original state
        }, 500);  // Flash red for 500ms
    }
}


function handleButtonCooldown(buttonId, progressBarColor = 'rgba(255, 0, 0, 0.6)') {
    let button = document.getElementById(buttonId);
    if (!button) {
        console.error("Couldn't find the button!");
        return;
    }
    button.disabled = true;
    // Remove any existing progress bar
    let existingProgressBar = button.querySelector('.sacrificeProgressBar');
    if (existingProgressBar) {
        button.removeChild(existingProgressBar);
    }
    // Create and append the progress bar
    let progressBar = document.createElement('div');
    progressBar.className = 'sacrificeProgressBar';
    progressBar.style.backgroundColor = progressBarColor;
    button.appendChild(progressBar);
    // Progress bar logic
    let startTime = Date.now();
    let duration = sacrificeDuration;
    let updateProgressBar = function() {
        if (!button.querySelector('.sacrificeProgressBar')) {
            console.error("Progress bar disappeared!");
            return;
        }
        let elapsed = Date.now() - startTime;
        let progress = (elapsed / duration) * 100;
        progressBar.style.width = progress + '%';
        if (progress < 100) {
            requestAnimationFrame(updateProgressBar);
        } else {
            if (button.querySelector('.sacrificeProgressBar')) {
                button.removeChild(progressBar);
            }
            button.disabled = false;
            // Check if auto-sacrifice is enabled for this resource
            const resourceName = buttonId.replace('Button', '');  
            if (enabledAutoSacrifices.includes(resourceName)) {
                const actualResourceName = resourceVariableNames[resourceName] || resourceName;
                const cost = getSacrificeCost(resourceName);
                if (canSacrifice(window[actualResourceName], cost)) {
                    // Re-trigger the sacrifice
                    const sacrificeFunction = sacrificeFunctions[resourceName];
                    if (sacrificeFunction) {
                      sacrificeFunction();  // Call the appropriate function
                    } else {
                      console.error(`Unknown resource type: ${resourceName}`);
                    }
                } else {
                    // Disable auto-sacrifice for this resource
                    console.log("DEBUG: insufficient resources to trigger auto-sacrifice, disabling glyph for:"+resourceName);
                    const index = enabledAutoSacrifices.indexOf(resourceName);
                    if (index > -1) {
                        enabledAutoSacrifices.splice(index, 1);
                    }
                    // Remove activeGlyph class from the glyph
                    document.getElementById(`${resourceName}Glyph`).classList.remove('activeGlyph');
                    updateSolaraGlyphFill();
                }
            }
        }
    };
    requestAnimationFrame(updateProgressBar);
}


function initiateSacrifice(resourceType, cost, pixelColor, buttonId, progressBarColor = 'rgba(255, 0, 0, 0.6)') {
    if (canSacrifice(window[resourceType], cost)) {
        // Deduct the resource
        deductResources(resourceType, cost);
        // Drop pixel into sacrifice pool
        dropPixelIntoSacrificePool(pixelColor);
        // Handle button cooldown and progress bar
        handleButtonCooldown(buttonId, progressBarColor);
        // If Ecliptic Synthesis research has been completed, drop a second pixel
        if (eclipticSynthesisResearchCompleted) {
            setTimeout(() => {
                dropPixelIntoSacrificePool(pixelColor);
            }, 2000); // Drop a second pixel after a delay
        }
    } else {
        flashButtonRed(buttonId);
    }
}




function cellSacrifice() {
    const resourceType = 'cellworkers';
    const cost = sacrificeStates.cellSacrificeCosts;
    const pixelColor = '#660000';
    const buttonId = 'cellButton';
    initiateSacrifice(resourceType, cost, pixelColor, buttonId, 'rgba(198, 5, 5, 0.81)');
    populateInfoWidget(); // required to update TF widget about new cell counts
}

function nourishmentSacrifice() {
    const resourceType = 'nourishment';
    const cost = sacrificeStates.nourishmentSacrificeCosts;
    const pixelColor = '#FFD700';
    const buttonId = 'nourishmentButton';
    initiateSacrifice(resourceType, cost, pixelColor, buttonId, 'rgba(255, 226, 0, 0.81)');
}


function warmthSacrifice() {
    const resourceType = 'warmth';
    const cost = sacrificeStates.warmthSacrificeCosts;
    const pixelColor = '#FF21B9';
    const buttonId = 'warmthButton';
    initiateSacrifice(resourceType, cost, pixelColor, buttonId, 'rgba(255, 186, 220, 0.81)');
}

function energySacrifice() {
    const resourceType = 'energy';
    const cost = sacrificeStates.energySacrificeCosts;
    const pixelColor = '#3A68DE';
    const buttonId = 'energyButton';
    initiateSacrifice(resourceType, cost, pixelColor, buttonId, 'rgba(31, 102, 252, 0.81)');
}

function biomiteSacrifice() {
    const resourceType = 'biomites';
    const cost = sacrificeStates.biomitesSacrificeCosts;
    const pixelColor = '#14DB60';
    const buttonId = 'biomitesButton';
    initiateSacrifice(resourceType, cost, pixelColor, buttonId, 'rgba(43, 236, 93, 0.81)');
}

function zymerSacrifice() {
    const resourceType = 'zymers';
    const cost = sacrificeStates.zymersSacrificeCosts;
    const pixelColor = '#F7821B';
    const buttonId = 'zymersButton';
    initiateSacrifice(resourceType, cost, pixelColor, buttonId, 'rgba(255, 121, 12, 0.81)');
}

function fiberSacrifice() {
    const resourceType = 'fibers';
    const cost = sacrificeStates.fibersSacrificeCosts;
    const pixelColor = '#7D5424';
    const buttonId = 'fibersButton';
    initiateSacrifice(resourceType, cost, pixelColor, buttonId, 'rgba(157, 101, 56, 0.81)');
}

function sludgeSacrifice() {
    const resourceType = 'sludge';
    const cost = sacrificeStates.sludgeSacrificeCosts;
    const pixelColor = '#209E81';
    const buttonId = 'sludgeButton';
    initiateSacrifice(resourceType, cost, pixelColor, buttonId, 'rgba(56, 157, 131, 0.81)');
}


function getSacrificeText(type) {
  return `Sacrifice ${formatNumber(sacrificeStates[type])}`;
}

const tabData = [
  {
    name: 'SolaraTab1',
    icon: icons.tab1,
    actions: Object.keys(sacrificeStates).map(type => getSacrificeText(type))
  },
  {
    name: 'SolaraTab2',
    icon: icons.tab2,
    actions: ['glyphs']
  },
  {
    name: 'SolaraTab3',
    icon: icons.tab3,
    actions: ['Auto-Sacrifice System I', 'Auto-Sacrifice System II', '33% Faster Terraform Cycle', 'Autonomous Mitogenesis', 'Protozoid Evolutions', '+1 Prestige Point', 'Endosymbiosis']
  }
];



function setupSolaraTab() {
  const solaraDiv = document.getElementById('Solara');
  // Check if subtabs already exist
  const existingSubtabs = solaraDiv.querySelector('.subtab');
  if (existingSubtabs) {
    return; // Exit the function if subtabs already exist
  }
  // Create a container to hold both subtab buttons and content
  const subTabContainer = document.createElement('div');
  subTabContainer.className = 'subtab';
  // Subtab buttons
  const subtabDiv = document.createElement('div');

  // Create a sibling div for the 'subtab' div - this will contain solara info like SP, progress etc.
  const solaraInfoDiv = document.createElement('div');
  solaraInfoDiv.textContent = 'Dummy Text';
  solaraInfoDiv.className = 'solaraInfo'; // Assigning a unique class name
  solaraInfoDiv.style.fontSize = '0.8em';  // Making the text size smaller
  solaraInfoDiv.style.float = 'right';     // Aligning the div to the right
  solaraInfoDiv.style.display = 'none';    // Initially hidden
  tabData.forEach((tab) => {
    const button = document.createElement('button');
    button.className = 'subtablinks solarabutton';
    button.innerHTML = tab.icon;
    button.onclick = (e) => openSubTab(e, tab.name);
    subtabDiv.appendChild(button);
  });
  subTabContainer.appendChild(subtabDiv);
  solaraDiv.appendChild(subTabContainer);
  solaraDiv.appendChild(solaraInfoDiv);
  // Container for subtab content
  const subTabContentContainer = document.createElement('div');
  subTabContainer.appendChild(subTabContentContainer);

  // Subtab content
  tabData.forEach((tab) => {
    const div = document.createElement('div');
    div.id = tab.name;
    div.className = 'subtabcontent';
    tab.actions.forEach((action) => {
      const button = document.createElement('button');
      button.className = 'solarabutton';
      // Create a unique ID for each button based on the tab name and action
      const uniqueId = `${tab.name}-${action.replace(/\s+/g, '_')}`;
      button.id = uniqueId;
      // Create div for action name
      const actionName = document.createElement('div');
      actionName.className = 'action-name';
      actionName.innerText = typeof action === "function" ? action() : action;
      button.appendChild(actionName);
      // Check if this is SolaraTab3 to add costs and attach specific listeners
      if (tab.name === 'SolaraTab3') {
          // Create tooltip container
        let tooltipContainer = document.createElement("div");
        tooltipContainer.className = "tooltip";
        button.setAttribute('data-tab', 'SolaraTab3');
        // Create tooltip text
        let tooltipText = document.createElement("span");
        tooltipText.className = "tooltiptext";
        tooltipText.innerHTML = tooltipTexts[button.id] || "";  // Use dictionary for tooltip text
        tooltipContainer.appendChild(button);
        tooltipContainer.appendChild(tooltipText);

        // Add tooltip positioning and visibility event listeners
        button.addEventListener('mousemove', () => {
          tooltipText.style.left = "120px";
          tooltipText.style.top = "60px";
        });

        button.addEventListener('mouseenter', () => {
          tooltipText.style.visibility = 'visible';
          tooltipText.style.opacity = '1';
        });

        button.addEventListener('mouseleave', () => {
          tooltipText.style.visibility = 'hidden';
          tooltipText.style.opacity = '0';
        });
        div.appendChild(tooltipContainer);  // Append to the relevant div
        // Create div for action cost
        const actionCost = document.createElement('div');
        actionCost.className = 'action-cost';
        actionCost.innerText = `Cost: ${getRitualCost(action)} SP`;  // Assuming you have a function getRitualCost
        actionCost.style.fontSize = '0.8em';
        button.appendChild(actionCost);

        // Attach the listener
        if (ritualHandlers[action] && !button.dataset.listenerAttached) {
          button.addEventListener('click', ritualHandlers[action]);
          button.dataset.listenerAttached = "true";
        }
      }
      // Check if this is SolaraTab2 to attach specific listeners and set up the altar
      if (tab.name === 'SolaraTab2') {
        // Create the ritual altar container
        const ritualAltar = document.createElement('div');
        ritualAltar.id = "ritualAltar";
        // Create and append the Solara glyph at the center
        const solaraGlyph = document.createElement('div');
        solaraGlyph.className = 'solaraGlyph';
        solaraGlyph.id = 'solaraGlyph';
        // Check if solaraCompleted is true and set content accordingly
        if (solaraCompleted) {
            solaraGlyph.innerHTML = visionRuneIcon; // Insert the SVG if solaraCompleted is true
        } else {
            solaraGlyph.textContent = '???'; // Otherwise, use '???'
        }
        ritualAltar.appendChild(solaraGlyph);
        // Append the ritual altar to SolaraTab2
        div.appendChild(ritualAltar);
        // Call the function to set up glyph listeners
        setupGlyphListeners();
        restoreActiveGlyphs(); 
      }
      // If it's SolaraTab3, then append the button
      if (tab.name === 'SolaraTab3') {
        div.appendChild(button);
        updateSacrificeButtonCosts();
      }
    });
    subTabContentContainer.appendChild(div);
    updateSolaraGlyph();
  });


  const solaraTab1Div = document.getElementById('SolaraTab1');
  // Wrap both sacrifice column and canvas in a container
  const solaraTab1Content = document.createElement('div');
  solaraTab1Content.className = 'solaraTab1-content';
  solaraTab1Div.appendChild(solaraTab1Content);

  // Create the 'sacrifice-column' container
  const sacrificeColumn = document.createElement('div');
  sacrificeColumn.className = 'sacrifice-column';

  // Create and append the header to the column
  const header = document.createElement('h3');
  header.innerText = 'Sacrifice';
  sacrificeColumn.appendChild(header);

  // For each sacrificeState, create a button
  for (let sacrifice in sacrificeStates) {
    const button = document.createElement('button');
    const textSpan = document.createElement('span');
    textSpan.className = 'sacrificeButtonTextContent'; 
    textSpan.innerText = `${sacrifice.split('SacrificeCosts')[0]} (${formatNumber(sacrificeStates[sacrifice])})`;
    button.appendChild(textSpan);
    button.className = 'solarabutton';
    // Create a unique ID for the button based on the sacrifice key
    let buttonId = sacrifice.split('SacrificeCosts')[0].toLowerCase() + 'Button';
    button.id = buttonId;
    
    // Create a unique name for the button based on the sacrifice key
    let buttonName = sacrifice.split('SacrificeCosts')[0].toLowerCase() + 'SacrificeButtonName';
    button.name = buttonName;
    // Attach the listener
    if (!button.dataset.listenerAttached) {  // Check if the listener is not attached yet
        button.addEventListener('click', sacrificeHandlers[sacrifice]);
        button.dataset.listenerAttached = "true";  // Mark that the listener has been attached
    }
    
    sacrificeColumn.appendChild(button);
  }


  // Append the 'sacrifice-column' to the wrapper
  solaraTab1Content.appendChild(sacrificeColumn);

  // Introduce the sacrifice Pool canvas
  const sacrificePoolCanvas = document.createElement('canvas');
  sacrificePoolCanvas.id = 'sacrificePool';
  solaraTab1Content.appendChild(sacrificePoolCanvas);

  initializeSacrificePoolCanvas();
  updateSolaraPointsDisplay();
  loadSavedSacrificePoolData(); // Loads up any saved solara pool data
}


// This code below ensures that the ??? text inside the solaraGlyph turns into the vision rune once the solara sacrifices are completed
function updateSolaraGlyph() {
    const solaraGlyph = document.getElementById('solaraGlyph');
    if (!solaraGlyph) {
        console.log("SolaraGlyph not found");
        return; // Exit if solaraGlyph is not found
    } 
    // Update the content if needed
    if (solaraCompleted && solaraGlyph.innerHTML !== visionRuneIcon) {
        // console.log("Updating SolaraGlyph content to vision rune icon");
        solaraGlyph.innerHTML = visionRuneIcon;
    } else {
        // console.log("SolaraGlyph content update not needed or solaraCompleted is false");
    }
    // Ensure clickability is always in place
    if (solaraCompleted) {
        if (!solaraGlyph.onclick) {
            //console.log("Adding click event listener to SolaraGlyph");
            solaraGlyph.style.cursor = 'pointer'; // Change cursor to pointer on hover
            solaraGlyph.onclick = unlockVisionEvolution; // Attach the function to the click event
        } else {
            //console.log("Click event listener already present on SolaraGlyph");
        }
    } else {
        //console.log("solaraCompleted is false, not adding click event listener");
    }
}

// When the vision rune is clicked
function unlockVisionEvolution() {
    const solaraGlyph = document.getElementById('solaraGlyph');
    // Check for required upgrades
    if (!ritualsPerformed.includes('Protozoid Evolutions') || !ritualsPerformed.includes('Endosymbiosis')) {
        // Flash the Solara Glyph red
        solaraGlyph.style.backgroundColor = 'darkred';
        setTimeout(() => {
            solaraGlyph.style.backgroundColor = '';
        }, 300);
        // Display message for lacking upgrades
        const message = "在进化和命运交织的道路中，你会发现符文共鸣着一首未实现的潜力之歌。它的低语诉说着尚未解开的旅程和尚未形成的纽带。要理解它的本质，你必须首先拥抱你自己的变革之旅，并与孤独的哨兵共生。";
        displayOnChat(message);
    } else {
        // Player has the required upgrades
        visionUnlocked = true;
        addToResearchQueue('PrimordialEyes'); 
        openTab(event, 'Research');
        // Hide the Solara tab
        document.getElementById("solaraTabButton").style.display = "none";
        // Display message for unlocking vision
        const message = "当你凝视符文的深处时，一连串看不见的颜色淹没了你的感官。在这个超越性觉醒的时刻，一个新的概念诞生了。除了感知，它是与宇宙的交流，是对光的空灵语言的理解。一个新的可能性领域展开了，因为你的存在结构将自己编织成一个更大意识的织锦。";
        displayOnChat(message);
    }
}



const ritualCosts = {
  'Auto-Sacrifice System I': 1,
  'Auto-Sacrifice System II': 3,
  '33% Faster Terraform Cycle': 6,
  'Autonomous Mitogenesis': 20,
  'Protozoid Evolutions': 30,
  '+1 Prestige Point': 60,
  'Endosymbiosis': 90
};

function getRitualCost(ritualName) {
  return ritualCosts[ritualName] || 'Unknown';  // Returns the cost if found, otherwise 'Unknown'
}


// A function to create and append a glyph div
function drawGlyph(resource) {
  const glyph = document.createElement('div');
  glyph.className = 'glyph';
  glyph.id = `${resource}Glyph`;
  glyph.textContent = resource.charAt(0).toUpperCase();
  ritualAltar.appendChild(glyph);
}


function clearExistingGlyphs() {
  const existingGlyphs = document.querySelectorAll('.glyph');
  existingGlyphs.forEach((glyph) => {
    glyph.remove();
  });
}



// Function to help bring solara tab3 buttons to the same width; better looks
function normalizeTab3ButtonWidths() {
  let maxWidth = 0;
  const tab3Buttons = document.querySelectorAll('[data-tab="SolaraTab3"]');
  tab3Buttons.forEach((button) => {
    const width = button.offsetWidth;
    if (width > maxWidth) {
      maxWidth = width;
    }
  });
  tab3Buttons.forEach((button) => {
    button.style.width = `${maxWidth}px`;
  });
}



function loadSavedSacrificePoolData() {
    const savedSacrificePoolCanvasData = localStorage.getItem('sacrificePoolState');
    const savedLastOccupiedPixelInRow = localStorage.getItem('lastOccupiedPixelInRow');
    // Only proceed if there's saved data
    if (savedSacrificePoolCanvasData && savedLastOccupiedPixelInRow) {
        groundSacrificePixelsRequired = true;
        console.log("Found saved sacrifice pool data, proceeding with loading of previous pool info");

        // Load the canvas image
        const sacrificePoolLoadCanvas = document.getElementById('sacrificePool');
        const sacrificeLoadCanvasctx = sacrificePoolLoadCanvas.getContext('2d');
        const sacrificepoolimg = new Image();
        sacrificepoolimg.onload = function() {
            sacrificeLoadCanvasctx.drawImage(sacrificepoolimg, 0, 0);
        };
        sacrificepoolimg.src = savedSacrificePoolCanvasData;

        // Load and parse the lastOccupiedPixelInRow array
        lastOccupiedPixelInRow = JSON.parse(savedLastOccupiedPixelInRow);
    }
}


function openSubTab(evt, tabName) {
  // Declare all variables
  var i, tabcontent, tablinks;
  // Get all elements with class="subtabcontent" and hide them
  tabcontent = document.getElementsByClassName("subtabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }
  // Get all elements with class="subtablinks" and remove the class "active"
  tablinks = document.getElementsByClassName("subtablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].classList.remove("active");
  }
  // Show the current tab, and add an "active" class to the button that opened the tab
  document.getElementById(tabName).style.display = "block";
  evt.currentTarget.classList.add("active");
  // Check if the tabName is 'SolaraTab1' and if groundSacrificePixelsRequired is true
  if (tabName === 'SolaraTab1' && groundSacrificePixelsRequired) {
    groundAllSacrificePixels();
    groundSacrificePixelsRequired = false;
    updateSolaraPointsDisplay(); 
    maybeDisplaySolaraTutorial();
  }
  if (tabName === 'SolaraTab3') {
    normalizeTab3ButtonWidths();
    updateRitualButtonAvailability();
    toggleBlurForEndosymbiosis();
  }
  if (tabName === 'SolaraTab2') {
    clearExistingGlyphs();
    // Check if Auto-Sacrifice System I has been performed
    if (ritualsPerformed.includes('Auto-Sacrifice System I')) {
      resourceTypes1.forEach(drawGlyph);
    }
    // Check if Auto-Sacrifice System II has been performed
    if (ritualsPerformed.includes('Auto-Sacrifice System II')) {
      resourceTypes2.forEach(drawGlyph);
    } 
    setupGlyphListeners();
    ensureActiveGlyphs();
    updateSolaraGlyphFill();
  }
  // Toggle solaraInfoDiv visibility based on the tab being opened
  const solaraInfo = document.querySelector('.solaraInfo');
  if (tabName === 'SolaraTab1') {
    solaraInfo.style.display = 'block';  // Show if SolaraTab1 is opened
  } else {
    solaraInfo.style.display = 'none';   // Hide otherwise
  }
  // Iterate through each to reset or set the min-height
  for (let i = 0; i < tabcontent.length; i++) {
    if (tabName === 'SolaraTab2') {
      tabcontent[i].style.minHeight = "333px";
    } else {
      tabcontent[i].style.minHeight = ""; // Reset the min-height
    }
  }
}



function ensureActiveGlyphs() {
  enabledAutoSacrifices.forEach((resourceName) => {
    console.log("checking to ensure activeglyph is on for.." + resourceName);
    const glyphElement = document.getElementById(`${resourceName}Glyph`);
    if (glyphElement && !glyphElement.classList.contains('activeGlyph')) {
      glyphElement.classList.add('activeGlyph');
      console.log(`Added activeGlyph to ${resourceName}Glyph`);
      updateSolaraGlyphFill();
    } else {
      console.log(`activeGlyph already exists on ${resourceName}Glyph or the element doesn't exist`);
    }
  });
}

function transformSVG(svgString, scale = 1) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgString, 'image/svg+xml');
    const svgElement = doc.documentElement;

    // Apply the transform attribute
    const transformValue = `translate(0,0) scale(${scale})`;
    svgElement.setAttribute('transform', transformValue);

    // Serialize the modified SVG back to a string
    const serializer = new XMLSerializer();
    return serializer.serializeToString(svgElement);
}


function formatNumber(n) {
  if (n < 1e3) return n; // Less than 1,000
  if (n >= 1e3 && n < 1e6) return +(n / 1e3).toFixed(1) + "K"; // Thousands
  if (n >= 1e6 && n < 1e9) return +(n / 1e6).toFixed(1) + "M"; // Millions
  if (n >= 1e9 && n < 1e12) return +(n / 1e9).toFixed(1) + "B"; // Billions
  return n; // If greater than billions, returns the number as-is. You can add more cases if needed.
}



function initializeSacrificePoolCanvas() {
  sacrificePoolCanvas = document.getElementById('sacrificePool');
  if (!sacrificePoolCanvas) {
    console.error("Sacrifice Pool Canvas not found in the DOM!");
    return;
  }
  sacrificePoolInitialized = true;
  sacrificePoolCtx = sacrificePoolCanvas.getContext('2d');
  sacrificePoolCtx.imageSmoothingEnabled = false;
  sacrificePoolCanvasWidth = 200;
  sacrificePoolCanvasHeight = 220;  // Adjust this to match the canvas height
  sacrificePoolCanvas.width = sacrificePoolCanvasWidth;
  sacrificePoolCanvas.height = sacrificePoolCanvasHeight;

  // First, fill the canvas with a solid color - we do this to avoid browsers being helpful and force-loading old images we no longer want...
  sacrificePoolCtx.fillStyle = "#FFFFFF"; 
  sacrificePoolCtx.fillRect(0, 0, sacrificePoolCanvasWidth, sacrificePoolCanvasHeight);
  // Now, clear it again to make it transparent
  sacrificePoolCtx.clearRect(0, 0, sacrificePoolCanvasWidth, sacrificePoolCanvasHeight);

  // This array will keep track of the last occupied pixel in each row.
  // Initialize lastOccupiedPixelInRow only if there's no saved game state
  const savedLastOccupiedPixelInRow = localStorage.getItem('lastOccupiedPixelInRow');
  if (!savedLastOccupiedPixelInRow) {
      lastOccupiedPixelInRow = new Array(sacrificePoolCanvasWidth).fill(sacrificePoolCanvasHeight);
  }
}




function findValidRowForSacrifice() {
  let validRows = [];
  // Iterate to find rows where the last pixel is not at the very top
  for (let i = 0; i < sacrificePoolCanvasWidth; i++) {
    if (lastOccupiedPixelInRow[i] > 0) {
      validRows.push(i);
    }
  }
  // If all rows are full, return -1 (you can handle this case in any way you want)
  if (validRows.length === 0) {
    return -1;
  }
  // Return a random row from the valid rows
  return validRows[Math.floor(Math.random() * validRows.length)];
}


function dropPixelIntoSacrificePool(color) {
  const row = findValidRowForSacrifice();
  if (row === -1) {
    //console.log("All rows in sacrifice pool are full!");
    ensureSufficientSolaraPointsForUpgrades();
    solaraCompleted = true;
    updateSolaraGlyph();
    enabledAutoSacrifices = [];
    return;
  }
  sacrificesMade += 1;
  let pixelPosY = 0;
  const pixelFlowInterval = setInterval(() => {
    // Clear the previous pixel in this row
    sacrificePoolCtx.clearRect(row, pixelPosY - 1 - 4, 1, 1);  // Clear the tail tip first
    // Draw the new pixel
    sacrificePoolCtx.fillStyle = color;
    sacrificePoolCtx.fillRect(row, pixelPosY, 1, 1);
    // Draw the fading tail
    for (let i = 1; i <= 4; i++) {
      let tailAlpha = 1 - (i * 0.2); // reduce alpha for each subsequent tail pixel
      let tailColor = convertHexToRgba(color, tailAlpha);
      sacrificePoolCtx.fillStyle = tailColor;
      sacrificePoolCtx.fillRect(row, pixelPosY - i, 1, 1);
    }
    pixelPosY++;
    // If the pixel hits another pixel or reaches the bottom, stop
    if (pixelPosY >= lastOccupiedPixelInRow[row]) {
      lastOccupiedPixelInRow[row] = pixelPosY - 1;
      clearInterval(pixelFlowInterval);
      setTimeout(() => removeTail(row, pixelPosY - 1 - 4), 0); // Pass initial position of the tail
      checkSacrificePoolRows(); 
      updateSolaraPointsDisplay(); 
    }
  }, 20);
}


// Function to remove the tail
function removeTail(row, tailStartPosY) {
  let delay = 10; // 20 ms delay to start removing tail
  for (let i = 0; i <= 3; i++) {  // Start from the tip of the tail
    setTimeout(() => {
      sacrificePoolCtx.clearRect(row, tailStartPosY + i, 1, 1);
    }, delay);
    delay += 20; // Increase delay for each pixel
  }
}


function groundAllSacrificePixels() {
    console.log("Now grounding pixels");
    const sacrificePoolCanvas = document.getElementById('sacrificePool');
    const ctx = sacrificePoolCanvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    const imageData = ctx.getImageData(0, 0, sacrificePoolCanvasWidth, sacrificePoolCanvasHeight);
    console.log(`Canvas Dimensions: ${sacrificePoolCanvasWidth}x${sacrificePoolCanvasHeight}`);
    const data = imageData.data;
 
    for (let x = 0; x < sacrificePoolCanvasWidth; ++x) {
        let y = sacrificePoolCanvasHeight - 1;
        let target = y;
        // Iterate through the whole height of the column
        while (y >= 0) {
            const index = (y * sacrificePoolCanvasWidth + x) * 4;
            // If the pixel is non-transparent
            if (data[index + 3] > 10) {
              // And if y has progressed farther than the target
              if (y < target) {
                  console.log("Found a floater! Gonna ground that sucker.")
                  // Move this non-transparent pixel to the target position
                  const targetIndex = (target * sacrificePoolCanvasWidth + x) * 4;
                  data[targetIndex] = data[index];
                  data[targetIndex + 1] = data[index + 1];
                  data[targetIndex + 2] = data[index + 2];
                  data[targetIndex + 3] = data[index + 3];
                  // Set the previous position of the non-transparent pixel to transparent
                  data[index] = 0;
                  data[index + 1] = 0;
                  data[index + 2] = 0;
                  data[index + 3] = 0;
                  // Check if grounding this pixel filled a row
                  checkSacrificePoolRows();
              }
              // Regardless, move target up when a non-transparent pixel is found
              --target;
            }
            --y;
        }
        // Fix lastOccupiedPixelInRow from any errors caused by floating pixels
        lastOccupiedPixelInRow[x] = target + 1;
    }
 
    ctx.putImageData(imageData, 0, 0);
}



function checkSacrificePoolRows() {
    const sacrificePoolCanvas = document.getElementById('sacrificePool');
    const ctx = sacrificePoolCanvas.getContext('2d');
    const width = sacrificePoolCanvas.width;
    const height = sacrificePoolCanvas.height;
    // Start at the last row based on currentRow. If currentRow = 0, start at y=219, etc.
    const startY = height - 1 - currentRow;
    // If we're trying to scan above the canvas, exit early
    if (startY < 0) {
        console.log("All rows have been checked!");
        return;
    }
    const imageData = ctx.getImageData(0, startY, width, 1); // Only get data for the row determined by solaraPoints
    const data = imageData.data;
    let filledPixelCount = 0;
    for (let x = 0; x < width; x++) {
        const index = x * 4; // We're only looking at one row, so we don't need y in our calculations
        const red = data[index];
        const green = data[index + 1];
        const blue = data[index + 2];
        // If any of the RGB values are non-zero, consider the pixel "filled"
        if (red !== 0 || green !== 0 || blue !== 0) {
            filledPixelCount++;
        }
    }
    // Logging the progress of the current row
    console.log(`Row at Y=${startY}: ${filledPixelCount} pixels out of ${width} are filled.`);
    // If all pixels in the row are filled
    if (filledPixelCount === width) {
        solaraPoints++;
        currentRow++;
        updateSolaraPointsDisplay();
        updateRitualButtonAvailability();
        console.log(`Row at Y=${startY} filled! Total Solara Points: ${solaraPoints}`);
    } //else {
        //console.log(`Row at Y=${startY} not fully filled.`);
    //}
}



function getFilledPixelCountForRow(row) {
    const sacrificePoolCanvas = document.getElementById('sacrificePool');
    const ctx = sacrificePoolCanvas.getContext('2d');
    const width = sacrificePoolCanvas.width;
    
    const imageData = ctx.getImageData(0, row, width, 1);
    const data = imageData.data;
    let filledPixelCount = 0;
    
    for (let x = 0; x < width; x++) {
        const index = x * 4; 
        const red = data[index];
        const green = data[index + 1];
        const blue = data[index + 2];
        if (red !== 0 || green !== 0 || blue !== 0) {
            filledPixelCount++;
        }
    }
    return filledPixelCount;
}


function updateSolaraPointsDisplay() {
    const solaraInfo = document.querySelector('.solaraInfo');
    if (solaraInfo) {
        const sacrificePoolCanvas = document.getElementById('sacrificePool');
        const height = sacrificePoolCanvas.height;
        // Use the global variable 'currentRow' directly
        const filledPixelCount = getFilledPixelCountForRow(height - 1 - currentRow);
        const progressPercentage = (filledPixelCount / 200 * 100).toFixed(1);
        solaraInfo.textContent = `Row: ${height - 1 - currentRow} Progress: ${progressPercentage}% SP: ${solaraPoints}`;
        if (progressPercentage === '100.0') {
            solaraInfo.style.color = 'blue';
            setTimeout(() => {
                solaraInfo.style.color = 'black';
                updateSolaraPointsDisplay(); // Refresh the display to show the next row's progress
            }, 1000); // Flash for 1 second
        }
    }
}


function generateRitualHandler(ritualName) {
  return function() {
    const cost = ritualCosts[ritualName];
    if (solaraPoints >= cost) {
      console.log(`Clicked ${ritualName} button`);
      ritualsPerformed.push(ritualName);
      startAutonomousMitogenesis(); // starts autonomous mitogenesis, if appropriate
      solaraPoints -= cost;  // Deduct the cost
      updateSolaraPointsDisplay();  // Assuming you have a function to update the UI
      updateRitualButtonAvailability();
      if (ritualName === 'Protozoid Evolutions') {
        enableProtozoidEvolutions();
      }
      if (ritualName === 'Endosymbiosis') {
        offerEndosymbioticEvolution('Endosymbiosis');
      }
      if (ritualName === '+1 Prestige Point') {
        checkPrestigeConditions(); // triggers the +1 add to prestige points
      }
    } else {
      console.log(`Not enough Solara Points to perform ${ritualName}`);
    }
  };
}

const ritualHandlers = {
  'Auto-Sacrifice System I': generateRitualHandler('Auto-Sacrifice System I'),
  'Auto-Sacrifice System II': generateRitualHandler('Auto-Sacrifice System II'),
  '33% Faster Terraform Cycle': generateRitualHandler('33% Faster Terraform Cycle'),
  'Autonomous Mitogenesis': generateRitualHandler('Autonomous Mitogenesis'),
  'Protozoid Evolutions': generateRitualHandler('Protozoid Evolutions'),
  '+1 Prestige Point': generateRitualHandler('+1 Prestige Point'),
  'Endosymbiosis': generateRitualHandler('Endosymbiosis'),
  // Add more as needed
};


// Step 1: Implement the Logic for 'Endosymbiosis'
// TODO: this should be used on loading a save, when endosymbiosis is not yet done, but the ritual is performed
// For now, this function isn't used, we need to alter it later to support the save/load usecase
function offerEndosymbioticEvolution(ritualName) {
  if (ritualName === 'Endosymbiosis') {
    if (evolvedToProtoWorm) {
      console.log('future content');
      //addEvolutionButton('Cactolith Serpent');
    } else if (evolvedToProtoPod) {
      console.log('future content');
      //addEvolutionButton('Trilactic Cactolith');
    } else if (evolvedToProtoCyst || evolvedToProtoGrade) {
      // Placeholder for future evolutions
    }
  }
}

// Step 2: Dynamically Add Evolution Buttons
function addEvolutionButton(evolutionName) {
  const evolutionDiv = document.getElementById("Evolution");
  const button = document.createElement("button");
  button.textContent = evolutionName;
  button.className = 'endosymbiosis-evolution-button'; 
  button.id = evolutionName.replace(/\s+/g, '') + 'Button';

  // Create tooltip container and text
  let tooltipContainer = document.createElement("div");
  tooltipContainer.className = "tooltip";
  let tooltipText = document.createElement("span");
  tooltipText.className = "tooltiptext";
  tooltipText.innerHTML = endosymbiosisEvolutionTooltips[evolutionName.replace(/\s+/g, '')];

  // Wrap the button with the tooltip container
  tooltipContainer.appendChild(button);
  tooltipContainer.appendChild(tooltipText);
  evolutionDiv.appendChild(tooltipContainer);

  // Add tooltip positioning and visibility event listeners
  button.addEventListener('mousemove', () => {
    tooltipText.style.left = "120px";
    tooltipText.style.top = "60px";
  });
  button.addEventListener('mouseenter', () => {
    tooltipText.style.visibility = 'visible';
    tooltipText.style.opacity = '1';
  });
  button.addEventListener('mouseleave', () => {
    tooltipText.style.visibility = 'hidden';
    tooltipText.style.opacity = '0';
  });

  button.style.display = 'block';
  button.addEventListener('click', () => performEndosymbioticEvolution(evolutionName));
}




function updateRitualButtonAvailability() {
  Object.keys(ritualCosts).forEach((ritualName) => {
    const buttonId = `SolaraTab3-${ritualName.replace(/\s+/g, '_')}`;
    const buttonElement = document.getElementById(buttonId);
    // Disable button if the player does not have enough Solara Points
    if (solaraPoints < ritualCosts[ritualName]) {
      buttonElement.disabled = true;
    } else {
      buttonElement.disabled = false;
    }
    // Check if the ritual has been performed
    if (ritualsPerformed.includes(ritualName)) {
      buttonElement.disabled = true;
      buttonElement.style.textDecoration = "line-through";
    } else {
      buttonElement.style.textDecoration = "none";
    }
  });
}




function setupGlyphListeners() {
  const glyphs = document.querySelectorAll('.glyph');
  glyphs.forEach((glyph) => {
    if (!glyph.dataset.listenerAttached) {
      const resourceName = glyph.id.replace('Glyph', '');
      if ((resourceTypes1.includes(resourceName) && ritualsPerformed.includes('Auto-Sacrifice System I')) ||
        (resourceTypes2.includes(resourceName) && ritualsPerformed.includes('Auto-Sacrifice System II'))) {
        glyph.addEventListener('click', function() {
          const actualResourceName = resourceVariableNames[resourceName] || resourceName;
          const cost = getSacrificeCost(resourceName);
          // Toggle class only if enough resources are available
          if (canSacrifice(window[actualResourceName], cost) || this.classList.contains('activeGlyph')) {
            this.classList.toggle('activeGlyph');
          } else {
            // If not enough resources, toggle class back after 0.5 seconds
            this.classList.add('activeGlyph');
            setTimeout(() => {
              this.classList.remove('activeGlyph');
            }, 500);
            return;
          }
          if (this.classList.contains('activeGlyph')) {
            enabledAutoSacrifices.push(resourceName);
            updateSolaraGlyphFill();
            const sacrificeFunction = sacrificeFunctions[resourceName];
            if (sacrificeFunction) {
              sacrificeFunction();
            } else {
              console.error(`Unknown resource type: ${resourceName}`);
            }
          } else {
            const index = enabledAutoSacrifices.indexOf(resourceName);
            if (index > -1) {
              enabledAutoSacrifices.splice(index, 1);
              updateSolaraGlyphFill();
            }
          }
        });
        glyph.dataset.listenerAttached = 'true';
      }
    }
  });
}


function restoreActiveGlyphs() {
  enabledAutoSacrifices.forEach((resource) => {
    const glyph = document.getElementById(`${resource}Glyph`);
    if (glyph) {
      glyph.classList.add('activeGlyph');
    }
  });
}


function getSacrificeCost(resourceName) {
  // Convert resourceName to match the keys in sacrificeStates
  const key = `${resourceName}SacrificeCosts`;
  return sacrificeStates[key];
}


function applyHarmonicSymbiosisImprovement() {
  // Apply a 10% reduction to each sacrifice cost, rounding up where necessary
  for (let costType in sacrificeStates) {
    if (costType !== 'cellSacrificeCosts') { // Exclude cell sacrifice cost from improvement
      sacrificeStates[costType] = Math.ceil(sacrificeStates[costType] * 0.9);
    }
  }
}


// Main function to handle Autonomous Mitogenesis
function autonomousMitogenesis() {
  // Generate a random increment between 75 and 100
  let increment = Math.floor(Math.random() * (100 - 75 + 1)) + 75;

  // Divide the increment into smaller parts for gradual appearance
  let smallIncrements = Math.floor(increment / 4);
  let remainingIncrement = increment - (smallIncrements * 3);

  // Apply the first three small increments
  for (let i = 1; i <= 3; i++) {
    setTimeout(() => {
      totalcellworkers += smallIncrements;
      cellworkers += smallIncrements;
      populateInfoWidget();  // Update the GUI
    }, i * 125);  // Delay by 125ms
  }

  // Apply the remaining increment
  setTimeout(() => {
    totalcellworkers += remainingIncrement;
    cellworkers += remainingIncrement;
    populateInfoWidget();  // Update the GUI
  }, 500);  // Complete after 500ms
}


function startAutonomousMitogenesis() {
  // First, clear any existing interval
  clearInterval(autonomousMitogenesisInterval);
  // Then, check if 'Autonomous Mitogenesis' has been performed
  if (ritualsPerformed.includes('Autonomous Mitogenesis')) {
    // If so, start the interval
    autonomousMitogenesisInterval = setInterval(autonomousMitogenesis, 10000);
  }
}


function toggleBlurForEndosymbiosis() {
  const endoButton = document.getElementById('SolaraTab3-Endosymbiosis');
  const actionName = endoButton.querySelector('.action-name');
  const actionCost = endoButton.querySelector('.action-cost');
  if (solaraGlyphActivated) {
    actionName.style.filter = 'blur(0px)';
    actionCost.style.filter = 'blur(0px)';
  } else {
    actionName.style.filter = 'blur(8px)';
    actionCost.style.filter = 'blur(8px)';
  }

  // Select all .tooltiptext elements in the parentNode and choose the last one
  const tooltips = endoButton.parentNode.querySelectorAll('.tooltiptext');
  const tooltip = tooltips[tooltips.length - 1];  // Selecting the last tooltip

  if (solaraGlyphActivated) {
    tooltip.style.filter = 'blur(0px)';
  } else {
    tooltip.style.filter = 'blur(8px)';
  }
}







// Function to update Solara glyph fill level
function updateSolaraGlyphFill() {
  const numActive = enabledAutoSacrifices.length;  // Number of active auto-sacrifices
  const targetFillPercentage = numActive * 12.5;  // Target fill percentage
  // Check if the targetFillPercentage reaches 100 and the special event hasn't been triggered yet
  if (targetFillPercentage === 100 && !solaraGlyphActivated) {
    solaraGlyphActivated = true;
    unlockAchievement(34);
    manipulateSacrificeCosts('nourishmentSacrificeCosts', 'divide', 2);
    manipulateSacrificeCosts('warmthSacrificeCosts', 'divide', 2);
    manipulateSacrificeCosts('energySacrificeCosts', 'divide', 2);
    manipulateSacrificeCosts('biomitesSacrificeCosts', 'divide', 2);
    manipulateSacrificeCosts('zymersSacrificeCosts', 'divide', 2);
    manipulateSacrificeCosts('fibersSacrificeCosts', 'divide', 2);
    manipulateSacrificeCosts('sludgeSacrificeCosts', 'divide', 2);
    updateSacrificeButtonCosts();
    displayOnChat("空气中弥漫着空灵的共鸣——一群看不见的声音合唱着最古老的赞美诗。 这些符号一致地跳动，它们的光芒反映了索拉拉本人的心跳。 在这种神圣的交流中，界限变得模糊； 索拉拉不仅仅是一个崇拜的对象，也是你存在的延伸。 一个新发现的选项在你面前显现出来：“内共生”。 在这个神圣的行为中，每一次奉献和牺牲的成本似乎都减少了，就好像宇宙本身为你的最终结合做好了准备");
  }
  function animateFill(timestamp) {
    const progress = (timestamp - start) / 1000;  // Progress in seconds
    const newFill = currentSolaraGlyphFill + (targetFillPercentage - currentSolaraGlyphFill) * progress;
    const solaraGlyph = document.getElementById('solaraGlyph');
    if (solaraGlyphActivated) {
      solaraGlyph.style.background = 'linear-gradient(to top, #add8e6 100%, #aaa 100%)';
      return;  // No more animations needed, exit the function
    }
    if (solaraGlyph) {
      solaraGlyph.style.background = `linear-gradient(to top, #9ae6aa ${newFill}%, #aaa ${newFill}%)`;
      if (currentSolaraGlyphFill < targetFillPercentage && newFill < targetFillPercentage) {
        requestAnimationFrame(animateFill);
      } else if (currentSolaraGlyphFill > targetFillPercentage && newFill > targetFillPercentage) {
        requestAnimationFrame(animateFill);
      } else {
        currentSolaraGlyphFill = targetFillPercentage;
      }
    }
  }

  const start = performance.now();
  requestAnimationFrame(animateFill);
}



function manipulateSacrificeCosts(costName, operation, value) {
  if (sacrificeStates.hasOwnProperty(costName)) {
    switch (operation) {
      case 'divide':
        sacrificeStates[costName] = Math.ceil(sacrificeStates[costName] / value);
        break;
      case 'multiply':
        sacrificeStates[costName] *= value; // For multiplication, rounding up is not typically necessary
        break;
      case 'add':
        sacrificeStates[costName] += value;
        break;
      case 'subtract':
        sacrificeStates[costName] = Math.ceil(sacrificeStates[costName] - value); // Use Math.ceil if you want to round up the subtraction result
        break;
      default:
        console.error("Invalid operation");
    }
  } else {
    console.error("Invalid cost name");
  }
}


function updateSacrificeButtonCosts() {
  for (let sacrifice in sacrificeStates) {
    // Get the button by its ID
    let buttonId = sacrifice.split('SacrificeCosts')[0].toLowerCase() + 'Button';
    let button = document.getElementById(buttonId);
    // Continue to the next iteration if the button doesn't exist
    if (!button) continue;
    // Use the existing formatNumber function to format the cost
    let formattedCost = formatNumber(sacrificeStates[sacrifice]);
    // Update the button text content
    let textSpan = button.querySelector('.sacrificeButtonTextContent');
    if (textSpan) {
      textSpan.innerText = `${sacrifice.split('SacrificeCosts')[0]} (${formattedCost})`;
    }
  }
}


function displaySolaraTutorialModal() {
    // Remove any existing modal
    var existingModal = document.getElementById('tutorialModal');
    if (existingModal) {
        document.body.removeChild(existingModal);
    }
    // Create the modal container
    var tutorialModal = document.createElement('div');
    tutorialModal.id = 'tutorialModal';
    tutorialModal.className = 'modal';

    // Create the modal content container
    var modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    modalContent.style.maxHeight = '600px';
    modalContent.style.overflowY = 'auto';

    // Add the image
    var img = document.createElement('img');
    img.src = 'img/tut_sol.png';
    img.style.border = '1px solid black';
    img.style.marginBottom = '20px';
    img.style.width = '50%';  // Set the width to 50% of the modal content's width
    img.style.maxWidth = '300px';  // Optional: Set a maximum width
    img.style.height = 'auto';  // Maintain the aspect ratio
    img.style.display = 'block';
    img.style.marginLeft = 'auto';
    img.style.marginRight = 'auto';
    modalContent.appendChild(img);

    // Introduction text
    var introText = [
        "A Tribute to Solara...",
        "In the loneliness of this vast world, you have discovered Solara, a lone sentinel standing resolute against the desolation. As your existence intertwines with hers, a profound bond forms, guiding you to honor her through offerings. The Solara minigame is a canvas of devotion, measuring 200 pixels in width and 220 pixels in height.",
        "Each offering, a sacrifice of your resources — cells, nourishment, warmth, energy, biomites, zymers, fibers, and sludge — manifests as a single pixel, descending to form an image honoring Solara's presence. Your sacrifices coalesce, building a mosaic of reverence and affection."
    ];

    introText.forEach(text => {
        var p = document.createElement('p');
        p.textContent = text;
        modalContent.appendChild(p);
    });

    // Further explanation
    var furtherExplanation = [
        "Completing the Mosaic...",
        "With each horizontal row you complete on the canvas, you are rewarded with a Solara Point (SP), a token of her acknowledgment and affinity. These points unlock upgrades to enhance your offerings, such as auto-sacrificers, making your tribute to Solara ever more efficient and heartfelt.",
        "Your journey with Solara is one of mutual growth and discovery. Each pixel, each sacrifice, strengthens the bond between you, unveiling new aspects of Solara and yourself in a shared path of existence."
    ];

    furtherExplanation.forEach(text => {
        var p = document.createElement('p');
        p.textContent = text;
        modalContent.appendChild(p);
    });

    // Close button
    var closeButton = document.createElement('button');
    closeButton.textContent = 'Got it!';
    closeButton.onclick = function() {
        tutorialModal.style.display = 'none';
    };
    modalContent.appendChild(closeButton);

    tutorialModal.appendChild(modalContent);
    document.body.appendChild(tutorialModal);
    tutorialModal.style.display = 'block';
}

function maybeDisplaySolaraTutorial() {
    console.log("DEBUG: calling Solara tutorial modal");
    if (tutorialsDisplayed.includes('solaratutorial')) {
        return; // If the tutorial has been shown before, we simply exit
    }
    displaySolaraTutorialModal(); 
    tutorialsDisplayed.push('solaratutorial'); // Add the identifier to the array to mark it as shown
}



function periodicallyGroundSacrificePixels() {
    // Set the interval to 5 minutes (300000 milliseconds)
    setInterval(function() {
        // Check if the sacrifice pool element exists and if sacrifices have been made
        if (document.getElementById('sacrificePool') && sacrificesMade > 0) {
            groundAllSacrificePixels();
        }
    }, 300000); // 300000 milliseconds = 5 minutes
}

// Call this function to start the periodic grounding, sometimes we randomly get a floater for whatever reason - no harm in just calling this every now n then
periodicallyGroundSacrificePixels();



// This function is a safety-check to ensure the player has enough SP to buy all upgrades remaining upon finishing the canvas
function ensureSufficientSolaraPointsForUpgrades() {
    let totalRequiredSP = 0;
    // Iterate over the ritualCosts to calculate total SP needed for remaining upgrades
    for (let ritual in ritualCosts) {
        if (!ritualsPerformed.includes(ritual)) {
            totalRequiredSP += ritualCosts[ritual];
        }
    }
    // Check if the player has enough SP
    if (solaraPoints < totalRequiredSP) {
        let neededSP = totalRequiredSP - solaraPoints;
        console.log(`Insufficient Solara Points. Adding ${neededSP} SP to ensure all upgrades can be purchased.`);
        solaraPoints += neededSP; // Add the missing SP
        updateSolaraPointsDisplay(); // Assuming you have a function to update the SP display
    } else {
        console.log("Sufficient Solara Points available for remaining upgrades.");
    }
}